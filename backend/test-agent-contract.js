#!/usr/bin/env node

/**
 * Test Agent â†’ Contract Interaction (Signature Testing)
 * 
 * This script tests:
 * - Agent authentication with signatures
 * - Contract interaction through Flow blockchain
 * - NFT minting with proper authorization
 * - Transaction signing and verification
 */

const { ethers } = require('ethers');
const axios = require('axios');

const BASE_URL = 'http://localhost:3001';

class AgentContractTester {
  constructor() {
    this.wallet = null;
    this.authToken = null;
    this.testResults = [];
  }

  async initialize() {
    console.log('ðŸ”§ Initializing Agent-Contract Tester...\n');
    
    // Create a test wallet
    this.wallet = ethers.Wallet.createRandom();
    console.log(`ðŸ“ Generated test wallet: ${this.wallet.address}`);
    console.log(`ðŸ”‘ Private key: ${this.wallet.privateKey}\n`);
  }

  async testAgentAuthentication() {
    console.log('ðŸ” Testing Agent Authentication...');
    
    try {
      // Step 1: Get authentication challenge
      const challengeResponse = await axios.post(`${BASE_URL}/api/auth/challenge`, {
        address: this.wallet.address
      });
      
      if (!challengeResponse.data.success) {
        throw new Error('Failed to get auth challenge');
      }
      
      const { message, nonce } = challengeResponse.data.data;
      console.log(`âœ… Received challenge: ${message}`);
      
      // Step 2: Sign the message
      const signature = await this.wallet.signMessage(message);
      console.log(`âœ… Signed message: ${signature.substring(0, 20)}...`);
      
      // Step 3: Verify signature and get token
      const verifyResponse = await axios.post(`${BASE_URL}/api/auth/verify`, {
        address: this.wallet.address,
        signature: signature,
        message: message,
        nonce: nonce
      });
      
      if (verifyResponse.data.success) {
        this.authToken = verifyResponse.data.data.token;
        console.log(`âœ… Authentication successful! Token: ${this.authToken.substring(0, 20)}...\n`);
        this.testResults.push({ test: 'Agent Authentication', status: 'PASSED' });
        return true;
      } else {
        throw new Error('Authentication verification failed');
      }
      
    } catch (error) {
      console.error(`âŒ Authentication failed: ${error.message}\n`);
      this.testResults.push({ test: 'Agent Authentication', status: 'FAILED', error: error.message });
      return false;
    }
  }

  async testContractInteraction() {
    console.log('ðŸ”— Testing Contract Interaction...');
    
    if (!this.authToken) {
      console.error('âŒ No auth token available. Skipping contract interaction test.\n');
      return false;
    }
    
    try {
      // Test 1: Mint NFT (Contract Interaction)
      const mintRequest = {
        recipient: this.wallet.address,
        metadata: {
          name: `Test Yodha #${Date.now()}`,
          description: 'A test Yodha NFT generated by automated testing',
          image: 'https://example.com/test-yodha.png',
          rarity: 'common',
          attributes: [
            { trait_type: 'Strength', value: '75' },
            { trait_type: 'Agility', value: '60' },
            { trait_type: 'Intelligence', value: '80' }
          ]
        }
      };
      
      const mintResponse = await axios.post(
        `${BASE_URL}/api/traits/generate`,
        mintRequest,
        {
          headers: {
            'Authorization': `Bearer ${this.authToken}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      if (mintResponse.data.success) {
        console.log(`âœ… NFT mint transaction initiated`);
        console.log(`ðŸ“ Transaction details:`, mintResponse.data.data);
        this.testResults.push({ test: 'Contract Interaction - NFT Mint', status: 'PASSED' });
      } else {
        throw new Error('NFT mint failed');
      }
      
      // Test 2: Battle Registration (Contract Interaction)
      const battleRequest = {
        attackerTokenId: '1',
        defenderTokenId: '2',
        battleType: 'ranked'
      };
      
      const battleResponse = await axios.post(
        `${BASE_URL}/api/battle/simulate`,
        battleRequest,
        {
          headers: {
            'Authorization': `Bearer ${this.authToken}`,
            'Content-Type': 'application/json'
          }
        }
      );
      
      if (battleResponse.data.success) {
        console.log(`âœ… Battle simulation successful`);
        console.log(`âš”ï¸ Battle result:`, battleResponse.data.data.result);
        this.testResults.push({ test: 'Contract Interaction - Battle', status: 'PASSED' });
      } else {
        console.log(`âš ï¸ Battle simulation returned:`, battleResponse.data);
        this.testResults.push({ test: 'Contract Interaction - Battle', status: 'PARTIAL' });
      }
      
      console.log('');
      return true;
      
    } catch (error) {
      console.error(`âŒ Contract interaction failed: ${error.message}\n`);
      this.testResults.push({ test: 'Contract Interaction', status: 'FAILED', error: error.message });
      return false;
    }
  }

  async testSignatureVerification() {
    console.log('ðŸ” Testing Signature Verification...');
    
    try {
      // Test message signing and verification
      const testMessage = `Verification test at ${new Date().toISOString()}`;
      const signature = await this.wallet.signMessage(testMessage);
      
      // Verify signature locally
      const recoveredAddress = ethers.verifyMessage(testMessage, signature);
      
      if (recoveredAddress.toLowerCase() === this.wallet.address.toLowerCase()) {
        console.log(`âœ… Local signature verification successful`);
        
        // Test with backend verification
        const verifyResponse = await axios.post(`${BASE_URL}/api/auth/verify-signature`, {
          message: testMessage,
          signature: signature,
          address: this.wallet.address
        });
        
        if (verifyResponse.data.success) {
          console.log(`âœ… Backend signature verification successful\n`);
          this.testResults.push({ test: 'Signature Verification', status: 'PASSED' });
          return true;
        } else {
          throw new Error('Backend signature verification failed');
        }
      } else {
        throw new Error('Local signature verification failed');
      }
      
    } catch (error) {
      console.error(`âŒ Signature verification failed: ${error.message}\n`);
      this.testResults.push({ test: 'Signature Verification', status: 'FAILED', error: error.message });
      return false;
    }
  }

  async runAllTests() {
    console.log('ðŸš€ Starting Agent â†’ Contract Interaction Tests\n');
    console.log('=' .repeat(60));
    
    await this.initialize();
    
    const tests = [
      () => this.testAgentAuthentication(),
      () => this.testContractInteraction(),
      () => this.testSignatureVerification()
    ];
    
    for (const test of tests) {
      await test();
      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s between tests
    }
    
    this.printResults();
  }

  printResults() {
    console.log('=' .repeat(60));
    console.log('ðŸ“Š TEST RESULTS SUMMARY:');
    console.log('=' .repeat(60));
    
    this.testResults.forEach((result, index) => {
      const icon = result.status === 'PASSED' ? 'âœ…' : result.status === 'PARTIAL' ? 'âš ï¸' : 'âŒ';
      console.log(`${icon} ${index + 1}. ${result.test}: ${result.status}`);
      if (result.error) {
        console.log(`   Error: ${result.error}`);
      }
    });
    
    const passed = this.testResults.filter(r => r.status === 'PASSED').length;
    const total = this.testResults.length;
    
    console.log('\n' + '=' .repeat(60));
    console.log(`ðŸŽ¯ Tests Passed: ${passed}/${total}`);
    console.log('=' .repeat(60));
  }
}

// Run the tests
if (require.main === module) {
  const tester = new AgentContractTester();
  tester.runAllTests().catch(console.error);
}

module.exports = AgentContractTester;
